h2. Engine入门

在这篇文档指南中，你会学到通过利用Engine， 以一种简洁易用的方式为主Rails应用程序提供额外的功能。你将学到如下的知识点：

* Engine的构成
* 怎么样生成一个Engine
* 怎么样给Engine添加功能
* 怎么样将Engine挂进（hook）主应用？
* 重载Engine的功能
endprologue.

h3. Engine是什么？

Engine可以被看作是一个为主Rails应用提供额外功能的小型应用.其实Rails应用程序本身就是一个大号的Engine，其中的 +Rails::Application+ 类就是继承自 +Rails::Engine+ ，它从其中承继了很多东西。

所以，Engine和Application这两个事物大可以被认为是一个东西，只是有一些细微的不同之处，在这篇文档指南会有讲到。Engine和Application都有一个普通的目录结构。

Engine和Rails插件也很相像，都有一个常见的lib目录，并且都是可以通过 +rails plugin new+ 命令来生成。它们的不同之处在于Engine可以被认为是一个完全的插件，从它的generator时可以传一个 +--full+ 选项可以看出这一点。但本文档指南中，两者都被作为Engine来对待，Engine可以是插件，插件也可以是Engine。

在本文中所要创建的Engine名为“blorgh”。通过这个Engine可以向主Rails应用中添加这样的功能：创建新文章、对文章发评论。在开始阶段，只在Engine中做事，在后面的章节，你会了解到怎么样将前面所做的挂进主应用中去。

主应用程序和Engine是分离的，这意味主应用中使用的路由Helper方法同样可以在Engine中使用，如+posts_path+ ，同时它们不会冲突，由此，控制器，模型和表名都是有命令空间的。在后面的章节会有说到。

记住这一点很重要：主应用是优先主它的Engine的，主程序整个应用环境中有优先权，这也就是说Engine是为主应用提供辅助的，而不是大幅度改变。

以下这些是一些Egnine的例子， "Devise":https://github.com/plataformatec/devise, 它为主应用提供了授权验证的功能。 "Forem":https://github.com/radar/forem, 它是一个论坛Engine。"Spree":https://github.com/spree/spree 是一个电子商务平台的Engine，"RefineryCMS":https://github.com/resolve/refinerycms, 是一个CMS Engine.

最后我想说的是,Engine的创建离不开James Adam、 Piotr Sarnacki、Rails核心团队、和其他许多人的工作，如果你遇到他们，不要忘记向他们说声谢谢哦！

h3. 生成一个Engine

在Rails 3.1中生成一个Engine，你需要在运行Plugin generator时传 +--full+ and +--mountable+这两个选项参数。生成“blorgh”Engine，你需要在终端运行如下的命令：

<shell>
$ rails plugin new blorgh --full --mountable
</shell>

+--full+ 这个选项告诉plugin generator，你想创建一个Engine（Engine就是一个可以绑定的插件嘛），创建了Engine的基本目录结构，如 +app+ 目录、 +config/routes.rb+ 文件，生成器也生成一个 +lib/blorgh/engine.rb+ 这个文件，它和Rails应用中的+config/application.rb+ 作用相当。

+--mountable+ 这个选项告诉plugin generator，你想将本Engine绑定测试环境中的application里，这个application位于 +test/dummy+ 中。在 +test/dummy/config/routes.rb+ 文件中有这行代码起到作用：

<ruby>
mount Blorgh::Engine, :at => "blorgh"
</ruby>

h4. Engine内部

h5. 主要文件

在刚创建的Engine根目录中有一个名为 +blorgh.gemspec+ 的文件。在后面当你将这个Engine添加你的应用中，需要在主应用中的 +Gemfile+ 文件中加入这行代码：

<ruby>
  gem 'blorgh', :path => "vendor/engines/blorgh"
</ruby>

在 +Gemfile+ 中将它指定为一个gem后，Bundler加载时，会解析 +blorgh.gemspec+ 文件，然后会require +lib+ 目录中的blorgh.rb文件。在 +lib/blorgh.rb+ 文件里，require了 +blorgh/engine.rb+ 文件（位于 +lib/blorgh/engine.rb+ ），并定定义了一个名为 +Blorgh+ 的Module。

<ruby>
require "blorgh/engine"

module Blorgh
end
</ruby>

提示: 一些Engine选择在这个文件中定义Engine的全局配置，如果你想提供配置选项时，在你的Engine的module定义的文件这样做是个不错的想法，在module中定义方法，也是不错的。

在 +lib/blorgh/engine.rb+ 文件中，定义了一个Engine基础类：

<ruby>
module Blorgh
  class Engine < Rails::Engine
    isolate_namespace Blorgh
  end
end
</ruby>

通过继承了 +Rails::Engine+ 类，这个gem告知Rails在指定的路径中有这样的一个Engine，并将其绑进Rails应用中，执行加载Engine中的app目录中的Controller、Model、View等。

The +isolate_namespace+ method here deserves special notice. This call is responsible for isolating the controllers, models, routes and other things into their own namespace, away from similar components inside hte application. Without this, there is a possibility that the engine's components could "leak" into the application, causing unwanted disruption, or that important engine components could be overriden by similarly named things within the application. One of the examples of such conflicts are helpers. Without calling +isolate_namespace+, engine's helpers would be included in application's controllers.

NOTE: It is *highly* recommended that the +isolate_namespace+ line be left within the +Engine+ class definition. Without it, classes generated in an engine *may* conflict with an application.

What this isolation of the namespace means is that a model generated by a call to +rails g model+ such as +rails g model post+ wouldn't be called +Post+, but instead be namespaced and called +Blorgh::Post+. In addition to this, the table for the model is namespaced, becoming +blorgh_posts+, rather than simply +posts+. Similar to the model namespacing, a controller called +PostsController+ would be +Blorgh::Postscontroller+ and the views for that controller would not be at +app/views/posts+, but rather +app/views/blorgh/posts+. Mailers would be namespaced as well.

Finally, routes will also be isolated within the engine. This is one of the most important parts about namespacing, and is discussed later in the "Routes":#routes section of this guide.

h5. +app+ directory

Inside the +app+ directory there is the standard +assets+, +controllers+, +helpers+, +mailers+, +models+ and +views+ directories that you should be familiar with from an application. The +helpers+, +mailers+ and +models+ directories are empty and so aren't described in this section. We'll look more into models in a future section, when we're writing the engine.

Within the +app/assets+ directory, there is the +images+, +javascripts+ and +stylesheets+ directories which, again, you should be familiar with due to their similarities of an application. One difference here however is that each directory contains a sub-directory with the engine name. Because this engine is going to be namespaced, its assets should be too.

Within the +app/controllers+ directory there is a +blorgh+ directory and inside that a file called +application_controller.rb+. This file will provide any common functionality for the controllers of the engine. The +blorgh+ directory is where the other controllers for the engine will go. By placing them within this namespaced directory, you prevent them from possibly clashing with identically-named controllers within other engines or even within the application.

NOTE: The +ApplicationController+ class is called as such inside an engine -- rather than +EngineController+ -- mainly due to that if you consider that an engine is really just a mini-application, it makes sense. You should also be able to convert an application to an engine with relatively little pain, and this is just one of the ways to make that process easier, albeit however so slightly.

Lastly, the +app/views+ directory contains a +layouts+ folder which contains file at +blorgh/application.html.erb+ which allows you to specify a layout for the engine. If this engine is to be used as a stand-alone engine, then you would add any customization to its layout in this file, rather than the applications +app/views/layouts/application.html.erb+ file.

If you don't want to force a layout on to users of the engine, then you can delete this file and reference a different layout in the controllers of your engine.

h5. +script+ directory

This directory contains one file, +script/rails+, which enables you to use the +rails+ sub-commands and generators just like you would within an application. This means that you will very easily be able to generate new controllers and models for this engine by running commands like this:

<shell>
rails g model
</shell>

Keeping in mind, of course, that anything generated with these commands inside an engine that has +isolate_namespace+ inside the Engine class will be namespaced.

h5. +test+ 目录

The +test+ directory is where tests for the engine will go. To test the engine, there is a cut-down version of a Rails application embedded within it at +test/dummy+. This application will mount the engine in the +test/dummy/config/routes.rb+ file:

<ruby>
Rails.application.routes.draw do

  mount Blorgh::Engine => "/blorgh"
end
</ruby>

这一行代码将Engine绑定在 +/blorgh+ 这个路由中，在应用中通过这个路径可以调用到Engine。

Also in the test directory is the +test/integration+ directory, where integration tests for the engine should be placed. Other directories can be created in the +test+ directory also. For example, you may wish to create a +test/unit+ directory for your unit tests.

h3. Providing engine functionality

The engine that this guide covers will provide posting and commenting functionality and follows a similar thread to the "Getting Started Guide":getting-started.html, with some new twists.

h4. Generating a post resource

The first thing to generate for a blog engine is the +Post+ model and related controller. To quickly generate this, you can use the Rails scaffold generator.

<shell>
$ rails generate scaffold post title:string text:text
</shell>

这行命令会生成如下信息:

<shell>
invoke  active_record
create    db/migrate/[timestamp]_create_blorgh_posts.rb
create    app/models/blorgh/post.rb
invoke    test_unit
create      test/unit/blorgh/post_test.rb
create      test/fixtures/blorgh/posts.yml
 route  resources :posts
invoke  scaffold_controller
create    app/controllers/blorgh/posts_controller.rb
invoke    erb
create      app/views/blorgh/posts
create      app/views/blorgh/posts/index.html.erb
create      app/views/blorgh/posts/edit.html.erb
create      app/views/blorgh/posts/show.html.erb
create      app/views/blorgh/posts/new.html.erb
create      app/views/blorgh/posts/_form.html.erb
invoke    test_unit
create      test/functional/blorgh/posts_controller_test.rb
invoke    helper
create      app/helpers/blorgh/posts_helper.rb
invoke      test_unit
create        test/unit/helpers/blorgh/posts_helper_test.rb
invoke  assets
invoke    js
create      app/assets/javascripts/blorgh/posts.js
invoke    css
create      app/assets/stylesheets/blorgh/posts.css
invoke  css
create    app/assets/stylesheets/scaffold.css
</shell>

The first thing that the scaffold generator does is invoke the +active_record+ generator, which generates a migration and a model for the resource. Note here, however, that the migration is called +create_blorgh_posts+ rather than the usual +create_posts+. This is due to the +isolate_namespace+ method called in the +Blorgh::Engine+ class's definition. The model here is also namespaced, being placed at +app/models/blorgh/post.rb+ rather than +app/models/post.rb+ due to the +isolate_namespace+ call within the +Engine+ class.

Next, the +test_unit+ generator is invoked for this model, generating a unit test at +test/unit/blorgh/post_test.rb+ (rather than +test/unit/post_test.rb+) and a fixture at +test/fixtures/blorgh/posts.yml+ (rather than +test/fixtures/posts.yml+).

After that, a line for the resource is inserted into the +config/routes.rb+ file for the engine. This line is simply +resources :posts+, turning the +config/routes.rb+ file for the engine into this:

<ruby>
Blorgh::Engine.routes.draw do
  resources :posts

end
</ruby>

Note here that the routes are drawn upon the +Blorgh::Engine+ object rather than the +YourApp::Application+ class. This is so that the engine routes are confined to the engine itself and can be mounted at a specific point as shown in the "test directory":#test-directory section. This is also what causes the engine's routes to be isolated from those routes that are within the application. This is discussed further in the "Routes":#routes section of this guide.

Next, the +scaffold_controller+ generator is invoked, generating a controlled called +Blorgh::PostsController+ (at +app/controllers/blorgh/posts_controller.rb+) and its related views at +app/views/blorgh/posts+. This generator also generates a functional test for the controller (+test/functional/blorgh/posts_controller_test.rb+) and a helper (+app/helpers/blorgh/posts_controller.rb+).

Everything this generator has created is neatly namespaced. The controller's class is defined within the +Blorgh+ module:

<ruby>
module Blorgh
  class PostsController < ApplicationController
    ...
  end
end
</ruby>

NOTE: The +ApplicationController+ class being inherited from here is the +Blorgh::ApplicationController+, not an application's +ApplicationController+.

The helper inside +app/helpers/blorgh/posts_helper.rb+ is also namespaced:

<ruby>
module Blorgh
  class PostsHelper
    ...
  end
end
</ruby>

This helps prevent conflicts with any other engine or application that may have a post resource also.

Finally, two files that are the assets for this resource are generated, +app/assets/javascripts/blorgh/posts.js+ and +app/assets/javascripts/blorgh/posts.css+. You'll see how to use these a little later.

By default, the scaffold styling is not applied to the engine as the engine's layout file, +app/views/blorgh/application.html.erb+ doesn't load it. To make this apply, insert this line into the +<head>+ tag of this layout:

<erb>
<%= stylesheet_link_tag "scaffold" %>
</erb>

You can see what the engine has so far by running +rake db:migrate+ at the root of our engine to run the migration generated by the scaffold generator, and then running +rails server+. When you open +http://localhost:3000/blorgh/posts+ you will see the default scaffold that has been generated.

!images/engines_scaffold.png(Blank engine scaffold)!

Click around! You've just generated your first engine's first functions.

If you'd rather play around in the console, +rails console+ will also work just like a Rails application. Remember: the +Post+ model is namespaced, so to reference it you must call it as +Blorgh::Post+.

<ruby>
  >> Blorgh::Post.find(1)
  => #<Blorgh::Post id: 1 ...>
</ruby>

One final thing is that the +posts+ resource for this engine should be the root of the engine. Whenever someone goes to the root path where the engine is mounted, they should be shown a list of posts. This can be made to happen if this line is inserted into the +config/routes.rb+ file inside the engine:

<ruby>
root :to => "posts#index"
</ruby>

Now people will only need to go to the root of the engine to see all the posts, rather than visiting +/posts+. This means that instead of +http://localhost:3000/blorgh/posts+, you only need to go to +http://localhost:3000/blorgh+ now.

h4. Generating a comments resource

Now that the engine has the ability to create new blog posts, it only makes sense to add commenting functionality as well. To do get this, you'll need to generate a comment model, a comment controller and then modify the posts scaffold to display comments and allow people to create new ones.

Run the model generator and tell it to generate a +Comment+ model, with the related table having two columns: a +post_id+ integer and +text+ text column.

<shell>
$ rails generate model Comment post_id:integer text:text
</shell>

This will output the following:
输出如下：

<shell>
invoke  active_record
create    db/migrate/[timestamp]_create_blorgh_comments.rb
create    app/models/blorgh/comment.rb
invoke    test_unit
create      test/unit/blorgh/comment_test.rb
create      test/fixtures/blorgh/comments.yml
</shell>

This generator call will generate just the necessary model files it needs, namespacing the files under a +blorgh+ directory and creating a model class called +Blorgh::Comment+.

To show the comments on a post, edit +app/views/posts/show.html.erb+ and add this line before the "Edit" link:

<erb>
<h3>Comments</h3>
<%= render @post.comments %>
</erb>

This line will require there to be a +has_many+ association for comments defined on the +Blorgh::Post+ model, which there isn't right now. To define one, open +app/models/blorgh/post.rb+ and add this line into the model:

<ruby>
has_many :comments
</ruby>

Turning the model into this:

<ruby>
module Blorgh
  class Post < ActiveRecord::Base
    has_many :comments
  end
end
</ruby>

NOTE: Because the +has_many+ is defined inside a class that is inside the +Blorgh+ module, Rails will know that you want to use the +Blorgh::Comment+ model for these objects, so there's no need to specify that using the +:class_name+ option here.

Next, there needs to be a form so that comments can be created on a post. To add this, put this line underneath the call to +render @post.comments+ in +app/views/blorgh/posts/show.html.erb+:

<erb>
<%= render "blorgh/comments/form" %>
</erb>

Next, the partial that this line will render needs to exist. Create a new directory at +app/views/blorgh/comments+ and in it a new file called +_form.html.erb+ which has this content to create the required partial:

<erb>
<h3>New comment</h3>
<%= form_for [@post, @post.comments.build] do |f| %>
  <p>
    <%= f.label :text %><br />
    <%= f.text_area :text %>
  </p>
  <%= f.submit %>
<% end %>
</erb>

When this form is submitted, it is going to attempt to perform a +POST+ request to a route of +/posts/:post_id/comments+ within the engine. This route doesn't exist at the moment, but can be created by changing the +resources :posts+ line inside +config/routes.rb+ into these lines:

<ruby>
resources :posts do
  resources :comments
end
</ruby>

This creates a nested route for the comments, which is what the form requires.

The route now exists, but the controller that this route goes to does not. To create it, run this command:

<shell>
$ rails g controller comments
</shell>

This will generate the following things:
这条命令会生成以下的文件：

<shell>
create  app/controllers/blorgh/comments_controller.rb
invoke  erb
 exist    app/views/blorgh/comments
invoke  test_unit
create    test/functional/blorgh/comments_controller_test.rb
invoke  helper
create    app/helpers/blorgh/comments_helper.rb
invoke    test_unit
create      test/unit/helpers/blorgh/comments_helper_test.rb
invoke  assets
invoke    js
create      app/assets/javascripts/blorgh/comments.js
invoke    css
create      app/assets/stylesheets/blorgh/comments.css
</shell>

The form will be making a +POST+ request to +/posts/:post_id/comments+, which will correspond with the +create+ action in +Blorgh::CommentsController+. This action needs to be created and can be done by putting the following lines inside the class definition in +app/controllers/blorgh/comments_controller.rb+:

<ruby>
def create
  @post = Post.find(params[:post_id])
  @comment = @post.comments.build(params[:comment])
  flash[:notice] = "Comment has been created!"
  redirect_to post_path
end
</ruby>

This is the final part required to get the new comment form working. Displaying the comments however, is not quite right yet. If you were to create a comment right now you would see this error:

<text>
  Missing partial blorgh/comments/comment with {:handlers=>[:erb, :builder], :formats=>[:html], :locale=>[:en, :en]}. Searched in:
    * "/Users/ryan/Sites/side_projects/blorgh/test/dummy/app/views"
    * "/Users/ryan/Sites/side_projects/blorgh/app/views"
</text>

The engine is unable to find the partial required for rendering the comments. Rails has looked firstly in the application's (+test/dummy+) +app/views+ directory and then in the engine's +app/views+ directory. When it can't find it, it will throw this error. The engine knows to look for +blorgh/comments/comment+ because the model object it is receiving is from the +Blorgh::Comment+ class.

This partial will be responsible for rendering just the comment text, for now. Create a new file at +app/views/blorgh/comments/_comment.html.erb+ and put this line inside it:

<erb>
<%= comment_counter + 1 %>. <%= comment.text %>
</erb>

The +comment_counter+ local variable is given to us by the +<%= render @post.comments %>+ call, as it will define this automatically and increment the counter as it iterates through each comment. It's used in this example to display a small number next to each comment when it's created.

That completes the comment function of the blogging engine. Now it's time to use it within an application.

h3. Hooking into an application

Using an engine within an application is very easy. This section covers how to mount the engine into an application and the initial setup required for it, as well as linking the engine to a +User+ class provided by the application to provide ownership for posts and comments within the engine.

h4. Mounting the engine

First, the engine needs to be specified inside the application's +Gemfile+. If there isn't an application handy to test this out in, generate one using the +rails new+ command outside of the engine directory like this:

<shell>
$ rails new unicorn
</shell>

Usually, specifying the engine inside the Gemfile would be done by specifying it as a normal, everyday gem.

通常情况下，在Gemfile文件中指定一个Egnine和指定一个Gem是一样的方法：

<ruby>
gem 'devise'
</ruby>

由于 +blorgh+ Engine还在开发中，在Gemfile中指定它时，需要传进一个 +:path+ 选项参数：

<ruby>
gem 'blorgh', :path => "/path/to/blorgh"
</ruby>

If the whole +blorgh+ engine directory is copied to +vendor/engines/blorgh+ then it could be specified in the +Gemfile+ like this:

<ruby>
gem 'blorgh', :path => "vendor/engines/blorgh"
</ruby>

As described earlier, by placing the gem in the +Gemfile+ it will be loaded when Rails is loaded, as it will first require +lib/blorgh.rb+ in the engine and then +lib/blorgh/engine.rb+, which is the file that defines the major pieces of functionality for the engine.

To make the engine's functionality accessible from within an application, it needs to be mounted in that application's +config/routes.rb+ file:

<ruby>
mount Blorgh::Engine, :at => "/blog"
</ruby>

This line will mount the engine at +/blog+ in the application. Making it accessible at +http://localhost:3000/blog+ when the application runs with +rails server+.

NOTE: Other engines, such as Devise, handle this a little differently by making you specify custom helpers such as +devise_for+ in the routes. These helpers do exactly the same thing, mounting pieces of the engines's functionality at a pre-defined path which may be customizable.

h4. Engine setup Engine的安装

The engine contains migrations for the +blorgh_posts+ and +blorgh_comments+ table which need to be created in the application's database so that the engine's models can query them correctly. To copy these migrations into the application use this command:
这个Engine中有 +blorgh_posts+ 和 +blorgh_comments+ 数据表的migration文件，Engine中的模型需要用到这两张表。通过执行这个命令将migration文件复制到Rails应用的相应目录中：

<shell>
$ rake blorgh:install:migrations
</shell>

If you have multiple engines that need migrations copied over, use +railties:install:migrations+ instead:
如果你有多个Engine的migration文件需要复制出来，可以使用 +railties:install:migrations+ 命令来代替：
<shell>
$ rake railties:install:migrations
</shell>

此命令在初次执行的时候，会将那些Engine中所有的migration文件都复制到Rails应用中。在下次执行这条命令时，只有那些还没有被复制出来的migration文件才会被复制出来。在初次执行此命令时，输出如下：
This command, when run for the first time will copy over all the migrations from the engine. When run the next time, it will only copy over migrations that haven't been copied over already. The first run for this command will output something such as this:

<shell>
Copied migration [timestamp_1]_create_blorgh_posts.rb from blorgh
Copied migration [timestamp_2]_create_blorgh_comments.rb from blorgh
</shell>

第一个时间戳 (+\[timestamp_1\]+) 是当前的时间，第二次时间戳是在当前的时间戳上加1秒 and the second timestamp (+\[timestamp_2\]+) will be the current time plus a second. The reason for this is so that the migrations for the engine are run after any existing migrations in the application.

To run these migrations within the context of the application, simply run +rake db:migrate+. When accessing the engine through +http://localhost:3000/blog+, the posts will be empty. This is because the table created inside the application is different from the one created within the engine. Go ahead, play around with the newly mounted engine. You'll find that it's the same as when it was only an engine.

If you would like to run migrations only from one engine, you can do it by specifying +SCOPE+:

<shell>
rake db:migrate SCOPE=blorgh
</shell>

This may be useful if you want to revert engine's migrations before removing it. In order to revert all migrations from blorgh engine you can run such code:

<shell>
rake db:migrate SCOPE=blorgh VERSION=0
</shell>

h4. Using a class provided by the application

When an engine is created, it may want to use specific classes from an application to provide links between the pieces of the engine and the pieces of the application. In the case of the +blorgh+ engine, making posts and comments have authors would make a lot of sense.

Usually, an application would have a +User+ class that would provide the objects that would represent the posts' and comments' authors, but there could be a case where the application calls this class something different, such as +Person+. It's because of this reason that the engine should not hardcode the associations to be exactly for a +User+ class, but should allow for some flexibility around what the class is called.

To keep it simple in this case, the application will have a class called +User+ which will represent the users of the application. It can be generated using this command inside the application:

<shell>
rails g model user name:string
</shell>

The +rake db:migrate+ command needs to be run here to ensure that our application has the +users+ table for future use.

Also, to keep it simple, the posts form will have a new text field called +author_name+ where users can elect to put their name. The engine will then take this name and create a new +User+ object from it or find one that already has that name, and then associate the post with it.

First, the +author_name+ text field needs to be added to the +app/views/blorgh/posts/_form.html.erb+ partial inside the engine. This can be added above the +title+ field with this code:

<erb>
<div class="field">
  <%= f.label :author_name %><br />
  <%= f.text_field :author_name %>
</div>
</erb>

The +Blorgh::Post+ model should then have some code to convert the +author_name+ field into an actual +User+ object and associate it as that post's +author+ before the post is saved. It will also need to have an +attr_accessor+ setup for this field so that the setter and getter methods are defined for it.

To do all this, you'll need to add the +attr_accessor+ for +author_name+, the association for the author and the +before_save+ call into +app/models/blorgh/post.rb+. The +author+ association will be hard-coded to the +User+ class for the time being.

<ruby>
attr_accessor :author_name
belongs_to :author, :class_name => "User"

before_save :set_author

private
  def set_author
    self.author = User.find_or_create_by_name(author_name)
  end
</ruby>

By defining that the +author+ association's object is represented by the +User+ class a link is established between the engine and the application. There needs to be a way of associating the records in the +blorgh_posts+ table with the records in the +users+ table. Because the association is called +author+, there should be an +author_id+ column added to the +blorgh_posts+ table.

To generate this new column, run this command within the engine:

<shell>
$ rails g migration add_author_id_to_blorgh_posts author_id:integer
</shell>

NOTE: Due to the migration's name and the column specification after it, Rails will automatically know that you want to add a column to a specific table and write that into the migration for you. You don't need to tell it any more than this.

This migration will need to be run on the application. To do that, it must first be copied using this command:

<shell>
$ rake blorgh:install:migrations
</shell>

Notice here that only _one_ migration was copied over here. This is because the first two migrations were copied over the first time this command was run.

<shell>
  NOTE: Migration [timestamp]_create_blorgh_posts.rb from blorgh has been skipped. Migration with the same name already exists.
  NOTE: Migration [timestamp]_create_blorgh_comments.rb from blorgh has been skipped. Migration with the same name already exists.
  Copied migration [timestamp]_add_author_id_to_blorgh_posts.rb from blorgh
</shell>

Run this migration using this command:

<shell>
$ rake db:migrate
</shell>

Now with all the pieces in place, an action will take place that will associate an author -- represented by a record in the +users+ table -- with a post, represented by the +blorgh_posts+ table from the engine.

Finally, the author's name should be displayed on the post's page. Add this code above the "Title" output inside +app/views/blorgh/posts/show.html.erb+:

<erb>
<p>
  <b>Author:</b>
  <%= @post.author %>
</p>
</erb>

By outputting +@post.author+ using the +<%=+ tag the +to_s+ method will be called on the object. By default, this will look quite ugly:

<text>
#<User:0x00000100ccb3b0>
</text>

This is undesirable and it would be much better to have the user's name there. To do this, add a +to_s+ method to the +User+ class within the application:

<ruby>
def to_s
  name
end
</ruby>

Now instead of the ugly Ruby object output the author's name will be displayed.

h4. Configuring an engine

This section covers firstly how you can make the +user_class+ setting of the Blorgh engine configurable, followed by general configuration tips for the engine.

h5. Setting configuration settings in the application

The next step is to make the class that represents a +User+ in the application customizable for the engine. This is because, as explained before, that class may not always be +User+. To make this customizable, the engine will have a configuration setting called +user_class+ that will be used to specify what the class representing users is inside the application.

To define this configuration setting, you should use a +mattr_accessor+ inside the +Blorgh+ module for the engine, located at +lib/blorgh.rb+ inside the engine. Inside this module, put this line:

<ruby>
mattr_accessor :user_class
</ruby>

This method works like its brothers +attr_accessor+ and +cattr_accessor+, but provides a setter and getter method on the module with the specified name. To use it, it must be referenced using +Blorgh.user_class+.

The next step is switching the +Blorgh::Post+ model over to this new setting. For the +belongs_to+ association inside this model (+app/models/blorgh/post.rb+), it will now become this:

<ruby>
belongs_to :author, :class_name => Blorgh.user_class
</ruby>

The +set_author+ method also located in this class should also use this class:

<ruby>
self.author = Blorgh.user_class.constantize.find_or_create_by_name(author_name)
</ruby>

To save having to call +constantize+ on the +user_class+ result all the time, you could instead just override the +user_class+ getter method inside the +Blorgh+ module in the +lib/blorgh.rb+ file to always call +constantize+ on the saved value before returning the result:

<ruby>
  def self.user_class
    @@user_class.constantize
  end
</ruby>

This would then turn the above code for +self.author=+ into this:

<ruby>
self.author = Blorgh.user_class.find_or_create_by_name(author_name)
</ruby>

Resulting in something a little shorter, and more implicit in its behaviour. The +user_class+ method should always return a +Class+ object.

To set this configuration setting within the application, an initializer should be used. By using an initializer, the configuration will be set up before the application starts and calls the engine's models which may depend on this configuration setting existing.

Create a new initializer at +config/initializers/blorgh.rb+ inside the application where the +blorgh+ engine is installed and put this content in it:

<ruby>
Blorgh.user_class = "User"
</ruby>

WARNING: It's very important here to use the +String+ version of the class, rather than the class itself. If you were to use the class, Rails would attempt to load that class and then reference the related table, which could lead to problems if the table wasn't already existing. Therefore, a +String+ should be used and then converted to a class using +constantize+ in the engine later on.

Go ahead and try to create a new post. You will see that it works exactly in the same way as before, except this time the engine is using the configuration setting in +config/initializers/blorgh.rb+ to learn what the class is.

There are now no strict dependencies on what the class is, only what the class's API must be. The engine simply requires this class to define a +find_or_create_by_name+ method which returns an object of that class to be associated with a post when it's created. This object, of course, should have some sort of identifier by which it can be referenced.

h5. General engine configuration

Within an engine, there may come a time where you wish to use things such as initializers, internationalization or other configuration options. The great news is that these things are entirely possible because a Rails engine shares much the same functionality as a Rails application. In fact, a Rails application's functionality is actually a superset of what is provided by engines!

If you wish to use an initializer -- code that should run before the engine is loaded -- the place for it is the +config/initializers+ folder. This directory's functionality is explained in the "Initializers section":http://guides.rubyonrails.org/configuring.html#initializers of the Configuring guide, and works precisely the same way as the +config/initializers+ directory inside an application. Same goes for if you want to use a standard initializer.

For locales, simply place the locale files in the +config/locales+ directory, just like you would in an application.

h3. Testing an engine

When an engine is generated there is a smaller dummy application created inside it at +test/dummy+. This application is used as a mounting point for the engine to make testing the engine extremely simple. You may extend this application by generating controllers, models or views from within the directory, and then use those to test your engine.

The +test+ directory should be treated like a typical Rails testing environment, allowing for unit, functional and integration tests.

h4. Functional tests

A matter worth taking into consideration when writing functional tests is that the tests are going to be running on an application -- the +test/dummy+ application -- rather than your engine. This is due to the setup of the testing environment; an engine needs an application as a host for testing its main functionality, especially controllers. This means that if you were to make a typical +GET+ to a controller in a controller's functional test like this:

<ruby>
get :index
</ruby>

It may not function correctly. This is because the application doesn't know how to route these requests to the engine unless you explicitly tell it *how*. To do this, you must pass the +:use_route+ option (as a parameter) on these requests also:

<ruby>
get :index, :use_route => :blorgh
</ruby>

This tells the application that you still want to perform a +GET+ request to the +index+ action of this controller, just that you want to use the engine's route to get there, rather than the application.

h3. Improving engine functionality

This section looks at overriding or adding functionality to the views, controllers and models provided by an engine.

h4. Overriding views

When Rails looks for a view to render, it will first look in the +app/views+ directory of the application. If it cannot find the view there, then it will check in the +app/views+ directories of all engines which have this directory.

In the +blorgh+ engine, there is a currently a file at +app/views/blorgh/posts/index.html.erb+. When the engine is asked to render the view for +Blorgh::PostsController+'s +index+ action, it will first see if it can find it at +app/views/blorgh/posts/index.html.erb+ within the application and then if it cannot it will look inside the engine.

By overriding this view in the application, by simply creating a new file at +app/views/blorgh/posts/index.html.erb+, you can completely change what this view would normally output.

Try this now by creating a new file at +app/views/blorgh/posts/index.html.erb+ and put this content in it:

<erb>
<h1>Posts</h1>
<%= link_to "New Post", new_post_path %>
<% @posts.each do |post| %>
  <h2><%= post.title %></h2>
  <small>By <%= post.author %></small>
  <%= simple_format(post.text) %>
  <hr>
<% end %>
</erb>

Rather than looking like the default scaffold, the page will now look like this:

!images/engines_post_override.png(Engine scaffold overriden)!

h4. Routes

Routes inside an engine are, by default, isolated from the application. This is done by the +isolate_namespace+ call inside the +Engine+ class. This essentially means that the application and its engines can have identically named routes, and that they will not clash.

Routes inside an engine are drawn on the +Engine+ class within +config/routes.rb+, like this:

<ruby>
  Blorgh::Engine.routes.draw do
    resources :posts
  end
</ruby>

By having isolated routes such as this, if you wish to link to an area of an engine from within an application, you will need to use the engine's routing proxy method. Calls to normal routing methods such as +posts_path+ may end up going to undesired locations if both the application and the engine both have such a helper defined.

For instance, the following example would go to the application's +posts_path+ if that template was rendered from the application, or the engine's +posts_path+ if it was rendered from the engine:

<erb>
<%= link_to "Blog posts", posts_path %>
</erb>

To make this route always use the engine's +posts_path+ routing helper method, we must call the method on the routing proxy method that shares the same name as the engine.

<erb>
<%= link_to "Blog posts", blorgh.posts_path %>
</erb>

If you wish to reference the application inside the engine in a similar way, use the +main_app+ helper:

<erb>
<%= link_to "Home", main_app.root_path %>
</erb>

If you were to use this inside an engine, it would *always* go to the application's root. If you were to leave off the +main_app+ "routing proxy" method call, it could potentially go to the engine's or application's root, depending on where it was called from.

If a template is rendered from within an engine and it's attempting to use one of the application's routing helper methods, it may result in an undefined method call. If you encounter such an issue, ensure that you're not attempting to call the application's routing methods without the +main_app+ prefix from within the engine.

h4. Assets

Assets within an engine work in an identical way to a full application. Because the engine class inherits from +Rails::Engine+, the application will know to look up in the engine's +app/assets+ directory for potential assets.

Much like all the other components of an engine, the assets should also be namespaced. This means if you have an asset called +style.css+, it should be placed at +app/assets/stylesheets/[engine name]/style.css+, rather than +app/assets/stylesheets/style.css+. If this asset wasn't namespaced, then there is a possibility that the host application could have an asset named identically, in which case the application's asset would take precedence and the engine's one would be all but ignored.

Imagine that you did have an asset located at +app/assets/stylesheets/blorgh/style.css+ To include this asset inside an application, just use +stylesheet_link_tag+ and reference the asset as if it were inside the engine:

<erb>
<%= stylesheet_link_tag "blorgh/style.css" %>
</erb>

You can also specify these assets as dependencies of other assets using the Asset Pipeline require statements in processed files:

<css>
/*
 *= require blorgh/style
*/
</css>

For more information, read the "Asset Pipeline guide":http://guides.rubyonrails.org/asset_pipeline.html

h4. Other gem dependencies

Gem dependencies inside an engine should be specified inside the +.gemspec+ file that's at the root of the engine. The reason for this is because the engine may be installed as a gem. If dependencies were to be specified inside the +Gemfile+, these would not be recognised by a traditional gem install and so they would not be installed, causing the engine to malfunction.

To specify a dependency that should be installed with the engine during a traditional +gem install+, specify it inside the +Gem::Specification+ block inside the +.gemspec+ file in the engine:

<ruby>
s.add_dependency "moo"
</ruby>

To specify a dependency that should only be installed as a development dependency of the application, specify it like this:

<ruby>
s.add_development_dependency "moo"
</ruby>

Both kinds of dependencies will be installed when +bundle install+ is run inside the application. The development dependencies for the gem will only be used when the tests for the engine are running.
